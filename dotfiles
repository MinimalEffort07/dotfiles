#!/usr/bin/env python3
"""
Install And Setup Config Files
"""

import argparse
import subprocess
import re
import tempfile
import sys

from platform import platform

from shutil import (
    copystat,
    copy,
    move,
    which,
)

from os import (
    environ,
    makedirs,
    symlink,
    remove,
)

from os.path import (
    dirname,
    abspath,
    exists,
)

print("""
       ██╗██████╗  ██████╗ ████████╗███████╗██╗██╗     ███████╗███████╗
      ██╔╝██╔══██╗██╔═══██╗╚══██╔══╝██╔════╝██║██║     ██╔════╝██╔════╝
     ██╔╝ ██║  ██║██║   ██║   ██║   █████╗  ██║██║     █████╗  ███████╗
    ██╔╝  ██║  ██║██║   ██║   ██║   ██╔══╝  ██║██║     ██╔══╝  ╚════██║
██╗██╔╝   ██████╔╝╚██████╔╝   ██║   ██║     ██║███████╗███████╗███████║
╚═╝╚═╝    ╚═════╝  ╚═════╝    ╚═╝   ╚═╝     ╚═╝╚══════╝╚══════╝╚══════╝""")


CYAN = "\x1b\x5b1m\x1b\x5b36m"
RED = "\x1b\x5b1m\x1b\x5b31m"
GREEN = "\x1b\x5b1m\x1b\x5b32m"
YELLOW = "\x1b\x5b1m\x1b\x5b33m"
RESET = "\x1b\x5b0m"

def print_info(text):
    """Print Info Style Message"""
    print(f"[{CYAN}INFO{RESET}] {text}")


def print_warn(text):
    """Print Warn Style Message"""
    print(f"[{YELLOW}WARN{RESET}] {text}")


def print_err(text):
    """Print Error Style Message"""
    print(f"[{RED}ERROR{RESET}] {text}")


def print_headers(text):
    """Print Header Style Message"""
    print(f"[{GREEN}SECTION{RESET}] {text}")


def style_path(text) -> str:
    """Stylize Path Strings"""
    return f"{GREEN}{text}{RESET}"


def sed_inplace(filename, pattern, repl) -> int:
    """
    Perform the pure-Python equivalent of in-place `sed` substitution: e.g.,
    `sed -i -e 's/'${pattern}'/'${repl}' "${filename}"`.
    """
    try:
        pattern_compiled = re.compile(pattern)

        with tempfile.NamedTemporaryFile(mode="w", delete=False) as tmp_file:
            with open(filename, mode='r', encoding='utf-8') as src_file:
                for line in src_file:
                    tmp_file.write(pattern_compiled.sub(repl, line))

        copystat(filename, tmp_file.name)
        move(tmp_file.name, filename)
    # pylint: disable=bare-except
    except:
        return 1

    return 0


description = f"""
Sets up Linux/MacOS machine with preferred software and configuration by:

[{CYAN} Installs Software Prerequisites {RESET}]
    1. Zsh
    2. Neovim
    3. Vim-plug
    4. i3
    5. brew (MacOS Only)

[{CYAN} Creates DOTFILES Environment Variable {RESET}]
    DOTFILES=/path/to/dotfiles/repository

    So that symlinks and aliases can find the dotfiles repository

    e.g.

    alias zshrc="nvim $DOTFILES/.zshrc"
    alias vimrc="nvim $DOTFILES/init.vim"
    ...

[{CYAN} Symlinks Configuration Files {RESET}]
    i.e:

    ~/.config/nvim/init.vim -> $DOTFILES/init.vim
    ~/.config/i3/config -> $DOTFILES/i3.config
    ~/.zshrc -> $DOTFILES/.zshrc
    ...
"""

parser = argparse.ArgumentParser(
    prog="dotfiles",
    description=description,
    formatter_class=argparse.RawTextHelpFormatter,
)

parser.add_argument(
    "--skip-install",
    action="store_true",
    required=False,
    dest="skip_install",
    help="Skips trying to install prerequisite software",
)

parser.add_argument(
    "-f",
    action="store_true",
    required=False,
    dest="force_sym_create",
    help="Backs up existing symlinks and creates new ones",
)

args = parser.parse_args()

# [ DETERMINING OS ]

# Determine operating system so we can use appropriate package manager
# Currently only support Debian package manager for Linux.. Will update if I
# ever start using Fedora?!

print_headers(" [ Determining Operating System ] ")

OS = "mac" if platform()[:5].lower() == "macos" else "linux"
print_info(f"{OS.upper()} Operating System Detected")

PACKAGE_MANAGER = "brew" if OS == "mac" else "apt"
print_info(f"Using '{PACKAGE_MANAGER}' Package Manager")

# [ SETTING UP DOTFILES ENVIRONMENT VARIABLE ]

print_headers(" [ Setting Up Environment Variables ] ")

environ["DOTFILES"] = dirname(abspath(__file__))
HOME_DIR = environ["HOME"]

if not environ["DOTFILES"]:
    print_err("Failed To Set $DOTFILES Environment Variable")
    sys.exit(1)
else:
    print_info(
        f'Set $DOTFILES Environment Variable To: "{style_path(environ["DOTFILES"])}"'
    )

# This updates the 'export DOTFILES=/path/to/dotfiles/repo/ with its new
# location on this machine.
SED_ENV_VAR_UPDATE = sed_inplace(
    f'{environ["DOTFILES"]}/zshrc', "DOTFILES=.*", f'DOTFILES="{environ["DOTFILES"]}"'
)

if SED_ENV_VAR_UPDATE:
    print_err(
        "Failed To Perform SED Substitution Of DOTFILES Environment Variable\n\n"
        + f"\t{SED_ENV_VAR_UPDATE}"
    )
    sys.exit(SED_ENV_VAR_UPDATE)
else:
    print_info("Updates $DOTFILES Environment Variable In .zshrc")

# [ SETUP PACKAGE MANAGER ]

if not args.skip_install:
    # If mac and brew isn't installed, install it.
    if OS == "mac" and not which("brew"):
        print_headers(" [ Setting Up Package Manager ] ")
        print_warn("Couldn't find Homebrew, Attempting To Install Homebrew")
        homebrew = subprocess.run(
            [
                "/bin/bash",
                "-c",
                (
                    '"$(curl -fsSL'
                    ' https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"'
                ),
            ],
            capture_output=True,
            check=True,
        )

        if homebrew.returncode:
            print_err(
                f"Failed To Install Homebrew\n\n\t{homebrew.stderr.decode('utf-8')}"
            )
            sys.exit(homebrew.returncode)
        else:
            print_info("Installed Homebrew")

# [ INSTALLING DEPENDENCIES AS PACKAGES ]
#   Dependencies are in the format of:
#       (name_of_executable,
#        name_of_package_it_resides_in or None,
#        os_not_to_install_on or None,
#        install_command_as_list_for_sub_process_or_none_defaulting_to_os_package_manager)
#
#       e.g. (nvim, neovim, None, None) or (i3, None, mac, None)
#

DEPENDENCIES = [
    ("curl", None, None, None),
    ("zsh", None, None, None),
    ("nvim", "neovim", None, None),
    ("i3", None, "mac", None),
    ("pip", None, None, None),
    (
        "vim-plug",
        None,
        None,
        [
            "curl",
            "-fL",
            "https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim",
            "-o",
            f"{environ['HOME']}/.local/share/nvim/site/autoload/plug.vim",
            "--create-dirs",
        ],
    ),
]

if not args.skip_install:
    print_headers(" [ Installing Dependencies ] ")

    LINUX_OPTIONS = "-y"
    MAC_OPTIONS = ""

    OPTIONS = MAC_OPTIONS if OS == "mac" else LINUX_OPTIONS

    for executable, package, bad_os, command in DEPENDENCIES:
        DEP_NAME = executable if not package else package

        if bad_os == OS:
            print_warn(f"{DEP_NAME} Not Required On {OS}, Skipping..")
            continue

        if which(executable):
            print_warn(f"{DEP_NAME} Already Installed")
            continue

        if command:
            print_info(f"Command Was Provided For {DEP_NAME}, Executing Command")
            cmd = subprocess.run(command, capture_output=True, check=True)
            if cmd.returncode:
                print_err(
                    f"Failed To Install {DEP_NAME}\n\n\t{cmd.stderr.decode('utf-8')}"
                )
                sys.exit(cmd.returncode)
            continue

        print_warn(f"{executable} Was Not Found.. Attempting To Install {DEP_NAME}")



        pkg = subprocess.run(
            [f"{PACKAGE_MANAGER}", "install", f"{OPTIONS}", f"{DEP_NAME}"],
            capture_output=True,
            check=True
        )

        if pkg.returncode:
            print_err(
                f"Failed To Install {DEP_NAME}\n\n\t{pkg.stderr.decode('utf-8')}"
            )
            sys.exit(pkg.returncode)
        else:
            print_info(f"Installed {DEP_NAME}")

# [ CREATING REQUIRED CONFIGURATION DIRECTORIES ]

print_headers(" [ Creating Required Configuration Directories ] ")

#   Configuration directories are in the format of:
#       (directory_path, os_not_to_create_on or None)
#
#       e.g. ("~/.config/nvim", None) or ("/root/.config/i3", mac)

CONFIG_DIRS = [
    (f"{HOME_DIR}/.config/nvim/", None),
    ("/root/.config/nvim/", "mac"),
    (f"{HOME_DIR}/.config/i3/", "mac"),
]

for config_dir, bad_os in CONFIG_DIRS:
    if bad_os == OS:
        print_warn(
            f'Not Creating Directory: "{style_path(config_dir)}" on {OS.upper()}'
        )
        continue

    try:
        makedirs(config_dir)
        print_info(f'Created Directory: "{style_path(config_dir)}"')
    except FileExistsError:
        print_warn(
            f'Attempted To Make Directory: "{style_path(config_dir)}" But It Already'
            " Exists"
        )

# [ CREATING SYMLINKS ]

print_headers(" [ Creating Configuration File Symlinks ] ")

#   Symlinks are in the format of:
#       (source, destination, os_not_to_create_on)
#
#   NOTE: That all source paths will have the value of $DOTFILES prepended to it
#       e.g. ("init.vim", "~/.config/nvim", None) or
#            ("init.vim", "/root/.config/nvim", mac)

SYMLINKS = [
    ("init.vim", f"{HOME_DIR}/.config/nvim/init.vim", None),  # USER init.vim
    ("init.vim", "/root/.config/nvim/init.vim", "mac"),       # ROOT init.vim
    ("i3_config", f"{HOME_DIR}/.config/i3/config", "mac"),    # i3 config
    ("zshrc", f"{HOME_DIR}/.zshrc", None),                    # zshrc
]

BACKUP_SUFFIX = ".dotfiles.bak"

for src, dest, bad_os in SYMLINKS:
    if bad_os == OS:
        print_warn(
            "Not Creating Symlink:"
            f" \"{style_path(dest+' -> '+environ['DOTFILES']+'/'+src)}\" on"
            f" {OS.upper()}"
        )
        continue

    try:
        print_info(
            "Attempting To Create Symlink:"
            f" \"{style_path(dest+' -> '+environ['DOTFILES']+'/'+src)}\""
        )
        symlink(abspath(src), abspath(dest))
    except FileExistsError:
        if not args.force_sym_create:
            print_err(
                "Couldn't Create Symlink:"
                f" \"{style_path(dest+' -> '+environ['DOTFILES']+'/'+src)}\""
            )
            sys.exit(1)

        if exists(abspath(dest + BACKUP_SUFFIX)):
            print_warn(
                f'Found Existing Backup File At: "{style_path(dest+BACKUP_SUFFIX)}",'
                " Removing It.."
            )
            remove(dest + BACKUP_SUFFIX)

        print_info(f'Creating New Backup File At: "{style_path(dest+BACKUP_SUFFIX)}"')

        copy(abspath(dest), abspath(dest + BACKUP_SUFFIX), follow_symlinks=False)

        remove(abspath(dest))
        symlink(abspath(src), abspath(dest))
        print_info(
            "Created Symlink:"
            f" \"{style_path(dest+' -> '+environ['DOTFILES']+'/'+src)}\""
        )
