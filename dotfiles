#!/usr/bin/env python3

# TODO:
#    - Vim Dictionary
#    - Handle Vim-Plug
#    - Copy dotfiles into /usr/bin if its not already there and exec zsh
#    - Provide option to not exec zsh at end of script
#    - Provide 'check' setup option which will give a status of what 
#      dependencies are already installed and which aren't, which symlinks have
#      been created and which haven't etc. 
#    - Display 'dotfiles' ASCII art once script finishes and in help screen. 

import argparse 
import subprocess
import re
import tempfile

from platform import platform
from shutil import (
        copystat,
        copy,
        move,
        which,
)

from os import (
        environ,
        path,
        makedirs,
        symlink,
        remove,
)

from os.path import (
        dirname,
        abspath,
        exists,
)

from colorama import (
        Fore,
        Style,
)

def print_info(text):
    print(f"[{Fore.LIGHTBLUE_EX}INFO{Style.RESET_ALL}] {text}")

def print_warn(text):
    print(f"[{Fore.YELLOW}WARN{Style.RESET_ALL}] {text}")

def print_err(text):
    print(f"[{Fore.RED}ERROR{Style.RESET_ALL}] {text}")

def print_verbose(text):
    print(f"[{Fore.GREEN}VERBOSE{Style.RESET_ALL}] {text}")

def style_path(text) -> str:
    return f'{Fore.GREEN}{text}{Style.RESET_ALL}'

def sed_inplace(filename, pattern, repl) -> int:
    '''
    Perform the pure-Python equivalent of in-place `sed` substitution: e.g.,
    `sed -i -e 's/'${pattern}'/'${repl}' "${filename}"`.
    '''
    try:
        pattern_compiled = re.compile(pattern)
        
        with tempfile.NamedTemporaryFile(mode='w', delete=False) as tmp_file:
            with open(filename) as src_file:
                for line in src_file:
                    tmp_file.write(pattern_compiled.sub(repl, line))

        copystat(filename, tmp_file.name)
        move(tmp_file.name, filename)
    except:
        return 1

    return 0

description = f"""
Sets up Linux/MacOS machine with preferred software and configuration by:

[{Fore.LIGHTBLUE_EX} Installs Software Prerequisites {Style.RESET_ALL}]
    1. Zsh
    2. Neovim
    3. Vim-plug
    4. i3
    5. brew (MacOS Only)

[{Fore.LIGHTBLUE_EX} Creates DOTFILES Environment Variable {Style.RESET_ALL}]
    DOTFILES=/path/to/dotfiles/repository

    So that symlinks and aliases can find the dotfiles repository

    e.g.

    alias zshrc="nvim $DOTFILES/.zshrc"
    alias vimrc="nvim $DOTFILES/init.vim"
    ...

[{Fore.LIGHTBLUE_EX} Symlinks Configuration Files {Style.RESET_ALL}]
    i.e:

    ~/.config/nvim/init.vim -> $DOTFILES/init.vim
    ~/.config/i3/config -> $DOTFILES/i3.config
    ~/.zshrc -> $DOTFILES/.zshrc
    ...
"""

parser = argparse.ArgumentParser(prog='dotfiles', 
                                 description=description,
                                 formatter_class=argparse.RawTextHelpFormatter)

parser.add_argument('--skip-install',
                    action='store_true',
                    required=False,
                    dest="skip_install",
                    help='Skips trying to install prerequisite software')

parser.add_argument('-f',
                    action='store_true',
                    required=False,
                    dest="force_sym_create",
                    help='Deletes existing symlinks and creates new ones')

args = parser.parse_args()

# [ DETERMINING OS ]

# Determine operating system so we can use appropriate package manager
# Currently only support Debian package manager for Linux.. Will update if I
# ever start using Fedora?!

OS = "mac" if platform()[:5].lower() == "macos" else "linux"

print_info(f"{OS.upper()} Operating System Detected")

PACKAGE_MANAGER = "brew" if OS == "mac" else "sudo apt"

print_info(f"Using '{PACKAGE_MANAGER}' Package Manager")

# [ SETTING UP DOTFILES ENVIRONMENT VARIABLE ]

environ["DOTFILES"] = dirname(abspath(__file__))
HOME_DIR = environ["HOME"] 

if not environ["DOTFILES"]:
    print_err("Failed To Set $DOTFILES Environment Variable")
    exit(1)
else:
    print_info(f'Set $DOTFILES Environment Variable To: \"{style_path(environ["DOTFILES"])}\"')

# This updates the 'export DOTFILES=/path/to/dotfiles/repo/ with its new 
# location on this machine.
sed = sed_inplace(f'{environ["DOTFILES"]}/zshrc', 'DOTFILES=.*', f'DOTFILES=\"{environ["DOTFILES"]}\"')

if sed:
    print_err("Failed To Perform SED Substitution Of DOTFILES Environment Variable\n\n"
              + f"\t{sed}")
    exit(sed)
else:
    print_info(f'Updates $DOTFILES Environment Variable In .zshrc')

# [ SETUP PACKAGE MANAGER ]

if not args.skip_install:
    # If mac and brew isn't installed, install it. 
    if OS == "mac" and not which('brew'):
        print_warn('Couldn\'t find Homebrew, Attempting To Install Homebrew')
        homebrew = subprocess.run(
            [
                '/bin/bash',
                '-c',
                '"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"'
            ],
            capture_output=True)
        
        if homebrew.returncode:
            print_err(f"Failed To Install Homebrew\n\n\t{homebrew.stderr.decode('utf-8')}")
            exit(homebrew.returncode)
        else:
            print_info(f"Installed Homebrew")

# [ INSTALLING DEPENDENCIES AS PACKAGES ]
#
#   Dependencies are in the format of: 
#       (name_of_executable,
#        name_of_package_it_resides_in or None,
#        os_not_to_install_on or None) 
#
#       e.g. (nvim, neovim, None) or (i3, None, mac)
#
DEPENDENCIES = [ 
    ("zsh", None, None), 
    ("nvim", "neovim", None),
    ("i3", None, "mac"),
]

if not args.skip_install:
    for (executable, package, bad_os) in DEPENDENCIES:

        install_obj = executable if not package else package

        if bad_os == OS:
            print_warn(f"{install_obj} Not Required On {OS}, Skipping..")
            continue

        if not which(executable) and OS != bad_os:

            print_warn(f"{executable} Was Not Found.. Attempting To Install {install_obj}")

            pkg = subprocess.run(
                [
                    f'{PACKAGE_MANAGER}',
                    'install',
                    f'{install_obj}'
                ],
                capture_output=True)

            if pkg.returncode:
                print_err(f"Failed To Install {install_obj}\n\n\t{pkg.stderr.decode('utf-8')}")
                exit(pkg.returncode)
            else:
                print_info(f"Installed {install_obj}")
        else:
            print_info(f"{executable} Already Installed")

# [ CREATING REQUIRED CONFIGURATION DIRECTORIES ]
#
#   Configuration directories are in the format of: 
#       (directory_path, os_not_to_create_on or None) 
#
#       e.g. ("~/.config/nvim", None) or ("/root/.config/i3", mac)

CONFIG_DIRS = [ (f"{HOME_DIR}/.config/nvim/", None),
                ("/root/.config/nvim/", "mac"),
                (f"{HOME_DIR}/.config/i3/", "mac") ]

for (config_dir, bad_os) in CONFIG_DIRS:
    if bad_os == OS:
        print_warn(f"Not Creating Directory: \"{style_path(config_dir)}\" on {OS}")
        continue

    try:
        mkdir = makedirs(config_dir)
        print_info(f"Created Directory: \"{style_path(config_dir)}\"")
    except FileExistsError:
        print_warn(f"Attempted To Make Directory: \"{style_path(config_dir)}\" But It Already Exists")

# [ CREATING SYMLINKS ]
#
#   Symlinks are in the format of: 
#       (source, destination, os_not_to_create_on) 
#
#   NOTE: That all source paths will have the value of $DOTFILES prepended to it
#       e.g. ("init.vim", "~/.config/nvim", None) or 
#            ("init.vim", "/root/.config/nvim", mac)

SYMLINKS = [ 
    ("init.vim", f"{HOME_DIR}/.config/nvim/init.vim", None),    # USER init.vim
    ("init.vim", "/root/.config/nvim/init.vim", "mac"),         # ROOT init.vim
    ("i3_config", f"{HOME_DIR}/.config/i3/config", "mac"),      # i3 config 
    ("zshrc", f"{HOME_DIR}/.zshrc", None),                      # zshrc 
]

BACKUP_SUFFIX = ".dotfiles_bak"

for (src, dest, bad_os) in SYMLINKS:

    if bad_os == OS:
        print_warn(f"Not Creating Symlink: \"{style_path(dest+' -> '+environ['DOTFILES']+'/'+src)}\" on {bad_os}")
        continue
    
    try:
        symlink(abspath(src), abspath(dest))
        print_info(f"Created Symlink: \"{style_path(dest+' -> '+environ['DOTFILES']+'/'+src)}\"")
    except FileExistsError:
        if not args.force_sym_create:
            print_err(f"Couldn't Create Symlink: \"{style_path(dest+' -> '+environ['DOTFILES']+'/'+src)}\"")
            exit(1)

        if exists(dest+BACKUP_SUFFIX):
            print_warn(f"Found Existing Backup File At: \"{style_path(dest+BACKUP_SUFFIX)}\", Removing It..")
            remove(dest+BACKUP_SUFFIX)

        print_info(f"Creating New Backup File At: \"{style_path(dest+BACKUP_SUFFIX)}\"")
        copy(dest, dest+BACKUP_SUFFIX)
        remove(dest)
        symlink(abspath(src), abspath(dest))
